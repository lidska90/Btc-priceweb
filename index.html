<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BTCUSDT Multi-timeframe Scalping Backtester (1m + 5m)</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>html,body,#app{height:100%} .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace}</style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div id="app" class="p-6 max-w-6xl mx-auto">
    <h1 class="text-2xl font-semibold mb-4">BTCUSDT Multi-timeframe Scalping Backtester</h1>

    <div class="bg-white shadow rounded p-4 mb-4">
      <div class="grid lg:grid-cols-2 gap-4">
        <div>
          <label class="block font-medium mb-1">Upload CSV 1m (optional — preferred)</label>
          <input id="file1m" type="file" accept=".csv" class="mb-2" />
          <div class="text-xs text-gray-600">CSV 1m should have columns: <span class="mono">open_time,open,high,low,close,volume</span>. If not provided, 5m will be used for both TFs.</div>
        </div>

        <div>
          <label class="block font-medium mb-1">Upload CSV 5m (required)</label>
          <input id="file5m" type="file" accept=".csv" class="mb-2" />
          <div class="text-xs text-gray-600">CSV 5m is required for the higher-timeframe trend filter.</div>
        </div>
      </div>

      <hr class="my-3" />

      <div class="grid grid-cols-2 gap-4">
        <div>
          <label class="block">1m EMA short</label>
          <input id="emaShort1m" type="number" value="9" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">1m EMA long</label>
          <input id="emaLong1m" type="number" value="21" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">5m EMA fast (trend)</label>
          <input id="emaFast5m" type="number" value="20" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">5m EMA slow (trend)</label>
          <input id="emaSlow5m" type="number" value="50" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">ATR period (1m)</label>
          <input id="atrPeriod" type="number" value="14" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">Risk per trade (%)</label>
          <input id="riskPct" type="number" value="1" step="0.1" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">TP (×ATR)</label>
          <input id="tpMult" type="number" value="1.5" step="0.1" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">Fee round-turn (%)</label>
          <input id="feePct" type="number" value="0.08" step="0.01" class="w-full p-2 border rounded" />
        </div>
      </div>

      <div class="mt-4 flex space-x-2">
        <button id="runBtn" class="px-4 py-2 bg-blue-600 text-white rounded shadow">Run Backtest</button>
        <button id="downloadBtn" class="px-4 py-2 bg-green-600 text-white rounded shadow">Download Trades CSV</button>
      </div>

      <div class="text-sm text-gray-600 mt-3">Behavior: strategy uses <b>5m</b> EMA fast/slow as higher-timeframe trend filter, and looks for EMA cross + RSI + MACD confirmation on <b>1m</b> for entries. If you upload only 5m, the engine will run on 5m for both roles.</div>
    </div>

    <div id="summary" class="bg-white shadow rounded p-4 mb-4 hidden">
      <h2 class="font-semibold text-lg mb-2">Summary</h2>
      <div id="summaryContent" class="text-sm"></div>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
      <div class="bg-white shadow rounded p-4">
        <h3 class="font-medium mb-2">Equity Curve</h3>
        <canvas id="equityChart" height="200"></canvas>
      </div>

      <div class="bg-white shadow rounded p-4">
        <h3 class="font-medium mb-2">Price (close) + trade markers</h3>
        <canvas id="priceChart" height="200"></canvas>
      </div>
    </div>

    <div class="bg-white shadow rounded p-4 mt-4">
      <h3 class="font-medium mb-2">Trade Log</h3>
      <div class="overflow-auto max-h-64">
        <table id="tradeTable" class="w-full text-sm table-auto border-collapse">
          <thead><tr class="bg-gray-100"><th class="p-2 border">#</th><th class="p-2 border">Type</th><th class="p-2 border">Entry Time</th><th class="p-2 border">Entry</th><th class="p-2 border">Exit</th><th class="p-2 border">SL</th><th class="p-2 border">TP</th><th class="p-2 border">Size</th><th class="p-2 border">PnL (USD)</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="text-xs text-gray-600 mt-3">Made for local/backtest use. No data leaves your browser.</div>
  </div>

<script>
// ---- Utilities ----
function parseCSV(text){
  const lines = text.split(/
?
/).filter(r=>r.trim());
  const header = lines[0].split(/,|;|	/).map(h=>h.trim());
  const rows = lines.slice(1).map(l=>{
    const parts = l.split(/,|;|	/);
    const obj = {};
    header.forEach((h,i)=> obj[h]=parts[i]);
    return obj;
  });
  return {header, rows};
}

function tryParseTimestamp(v){
  if(!v) return null;
  if(/^[0-9]{12,}$/.test(v)) return new Date(Number(v));
  const d = new Date(v);
  if(!isNaN(d)) return d;
  const d2 = new Date(v.replace(' ', 'T'));
  if(!isNaN(d2)) return d2;
  return null;
}

function toISOUTC(d){ const dt = new Date(d); return new Date(Date.UTC(dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), dt.getMinutes(), dt.getSeconds())).toISOString(); }

// ---- Indicators ----
function ema(values, period){
  const k = 2/(period+1); const out=[]; let prev=null;
  for(let i=0;i<values.length;i++){
    const v = values[i];
    if(i===0) { out.push(null); prev=v; continue; }
    if(i<period-1){ out.push(null); prev = (prev + v); continue; }
    if(i===period-1){
      const sum = values.slice(0,period).reduce((a,b)=>a+b,0); prev = sum/period; out.push(prev); continue;
    }
    prev = v*k + prev*(1-k); out.push(prev);
  }
  return out;
}
function sma(values, period){ const out=[]; let sum=0; for(let i=0;i<values.length;i++){ sum+=values[i]; if(i>=period) sum-=values[i-period]; out.push(i<period-1?null:sum/period);} return out; }
function rsi(values, period){ const out=new Array(values.length).fill(null); let gains=0, losses=0; for(let i=1;i<values.length;i++){ const change = values[i]-values[i-1]; gains += Math.max(0,change); losses += Math.max(0,-change); if(i>=period){ if(i>period){ const prevChange = values[i-period+1]-values[i-period]; gains -= Math.max(0, prevChange); losses -= Math.max(0, -prevChange); } const avgG=gains/period; const avgL=losses/period; const rs = avgL===0?100:avgG/avgL; out[i]=100 - (100/(1+rs)); } } return out; }
function macd(values, shortP=12,longP=26,signalP=9){ const emaS = ema(values, shortP); const emaL = ema(values, longP); const macdLine = values.map((v,i)=> (emaS[i]!=null && emaL[i]!=null) ? emaS[i]-emaL[i] : null); const macdVals = macdLine.map(v=> v==null?0:v); const signal = ema(macdVals, signalP); const hist = macdLine.map((v,i)=> (v!=null && signal[i]!=null)? v - signal[i] : null); return {macdLine, signal, hist}; }
function atr(high, low, close, period){ const tr=[]; for(let i=0;i<close.length;i++){ if(i===0){ tr.push(high[i]-low[i]); continue; } tr.push(Math.max(high[i]-low[i], Math.abs(high[i]-close[i-1]), Math.abs(low[i]-close[i-1]))); } return sma(tr, period); }

// ---- Data builders ----
function buildSeriesFromRows(rows){ const time=[], open=[], high=[], low=[], close=[], volume=[]; for(const r of rows){ const t = tryParseTimestamp(r.open_time || r.openTime || r[Object.keys(r)[0]]); if(!t) continue; time.push(new Date(t).toISOString()); open.push(parseFloat(r.open)); high.push(parseFloat(r.high)); low.push(parseFloat(r.low)); close.push(parseFloat(r.close)); volume.push(parseFloat(r.volume || r.qty || 0)); } return {time, open, high, low, close, volume}; }

function map1mTo5mIndex(time1m, time5m){ // for each 1m timestamp find corresponding 5m index (floor to nearest 5-min)
  const map = new Array(time1m.length).fill(0);
  const time5mSet = {};
  for(let j=0;j<time5m.length;j++){ time5mSet[new Date(time5m[j]).toISOString()] = j; }
  for(let i=0;i<time1m.length;i++){
    const d = new Date(time1m[i]);
    const floored = new Date(d); floored.setUTCMinutes(Math.floor(d.getUTCMinutes()/5)*5, 0,0);
    const key = floored.toISOString();
    if(key in time5mSet) map[i] = time5mSet[key]; else {
      // fallback: find nearest earlier 5m by decreasing minutes until found (max 4 steps)
      let found=null; for(let k=0;k<5;k++){ const mm = new Date(floored); mm.setUTCMinutes(floored.getUTCMinutes()-k); const kk = new Date(mm); kk.setUTCMinutes(Math.floor(kk.getUTCMinutes()/5)*5,0,0); const key2=kk.toISOString(); if(key2 in time5mSet){ found = time5mSet[key2]; break; } }
      map[i] = found===null?0:found;
    }
  }
  return map;
}

// ---- Backtest engine (1m execution, 5m trend filter) ----
function runBacktest1mWith5m(data1m, data5m, params){
  const n = data1m.close.length;
  const emaShort1 = ema(data1m.close, params.emaShort1m);
  const emaLong1 = ema(data1m.close, params.emaLong1m);
  const rsi1 = rsi(data1m.close, params.rsiPeriod);
  const macd1 = macd(data1m.close, params.macdShort, params.macdLong, params.macdSignal);
  const atr1 = atr(data1m.high, data1m.low, data1m.close, params.atrPeriod);

  const emaFast5 = ema(data5m.close, params.emaFast5m);
  const emaSlow5 = ema(data5m.close, params.emaSlow5m);
  const map1to5 = map1mTo5mIndex(data1m.time, data5m.time);

  const trades=[]; let equity = params.initialEquity; const equityCurve=[]; let position=null;

  for(let i=0;i<n;i++){
    if(emaShort1[i]==null || emaLong1[i]==null || rsi1[i]==null || atr1[i]==null) { equityCurve.push(equity); continue; }
    const price = data1m.close[i]; const atrv = atr1[i]; const idx5 = map1to5[i];
    const trendUp = (emaFast5[idx5]!=null && emaSlow5[idx5]!=null) ? emaFast5[idx5] > emaSlow5[idx5] : null;
    const trendDown = (emaFast5[idx5]!=null && emaSlow5[idx5]!=null) ? emaFast5[idx5] < emaSlow5[idx5] : null;

    if(!position){
      // long entry: 1m ema cross (short>long) && trendUp on 5m && rsi>50 && macd hist >0
      const crossUp = (i>0 && emaShort1[i-1] <= emaLong1[i-1] && emaShort1[i] > emaLong1[i]);
      if(crossUp && trendUp && rsi1[i] > 50 && macd1.hist[i] > 0){
        const sl = price - atrv; const tp = price + params.tpMult*atrv; const riskAmt = equity * (params.riskPct/100); const size = riskAmt / (price - sl);
        position = {type:'long', entryPrice:price, sl, tp, size, entryTime:data1m.time[i]}; trades.push(Object.assign({entryTime:data1m.time[i]}, position));
      }
      // short
      const crossDown = (i>0 && emaShort1[i-1] >= emaLong1[i-1] && emaShort1[i] < emaLong1[i]);
      if(crossDown && trendDown && rsi1[i] < 50 && macd1.hist[i] < 0){
        const sl = price + atrv; const tp = price - params.tpMult*atrv; const riskAmt = equity * (params.riskPct/100); const size = riskAmt / (sl - price);
        position = {type:'short', entryPrice:price, sl, tp, size, entryTime:data1m.time[i]}; trades.push(Object.assign({entryTime:data1m.time[i]}, position));
      }
    } else {
      // manage open
      if(position.type==='long'){
        if(price <= position.sl || price >= position.tp){
          const exit = price; const gross = (exit - position.entryPrice) * position.size; const fee = (position.entryPrice*position.size + exit*position.size) * (params.feePct/100); const pnl = gross - fee; trades[trades.length-1].exitPrice = exit; trades[trades.length-1].exitTime = data1m.time[i]; trades[trades.length-1].pnl = pnl; equity += pnl; position=null;
        }
      } else {
        if(price >= position.sl || price <= position.tp){
          const exit = price; const gross = (position.entryPrice - exit) * position.size; const fee = (position.entryPrice*position.size + exit*position.size) * (params.feePct/100); const pnl = gross - fee; trades[trades.length-1].exitPrice = exit; trades[trades.length-1].exitTime = data1m.time[i]; trades[trades.length-1].pnl = pnl; equity += pnl; position=null;
        }
      }
    }
    equityCurve.push(equity);
  }

  return {trades, equityCurve};
}

// ---- UI wiring ----
let rows1m = null, rows5m = null, parsedResults = null;

document.getElementById('file1m').addEventListener('change', (e)=>{ const f = e.target.files[0]; if(!f) return; const r = new FileReader(); r.onload = ev => { const p = parseCSV(ev.target.result); rows1m = p.rows; alert('Loaded 1m CSV: '+rows1m.length+' rows'); }; r.readAsText(f); });
document.getElementById('file5m').addEventListener('change', (e)=>{ const f = e.target.files[0]; if(!f) return; const r = new FileReader(); r.onload = ev => { const p = parseCSV(ev.target.result); rows5m = p.rows; alert('Loaded 5m CSV: '+rows5m.length+' rows'); }; r.readAsText(f); });

function buildAndRun(){
  if(!rows5m) return alert('Please upload 5m CSV (required)');
  let data5m = buildSeriesFromRows(rows5m);
  let data1m = rows1m ? buildSeriesFromRows(rows1m) : data5m; // fallback to 5m if 1m missing

  const params = {
    emaShort1m: parseInt(document.getElementById('emaShort1m').value),
    emaLong1m: parseInt(document.getElementById('emaLong1m').value),
    emaFast5m: parseInt(document.getElementById('emaFast5m').value),
    emaSlow5m: parseInt(document.getElementById('emaSlow5m').value),
    atrPeriod: parseInt(document.getElementById('atrPeriod').value),
    tpMult: parseFloat(document.getElementById('tpMult').value),
    riskPct: parseFloat(document.getElementById('riskPct').value),
    feePct: parseFloat(document.getElementById('feePct').value),
    initialEquity: 1000,
    rsiPeriod: 14, macdShort:12, macdLong:26, macdSignal:9
  };

  const res = runBacktest1mWith5m(data1m, data5m, params);

  // show summary
  document.getElementById('summary').classList.remove('hidden');
  const trades = res.trades; const n = trades.length; const net = trades.reduce((s,t)=> s + (t.pnl||0), 0); const wins = trades.filter(t=> (t.pnl||0) > 0).length; const winRate = n? (wins/n*100).toFixed(2):0; const ending = res.equityCurve[res.equityCurve.length-1] || params.initialEquity; const maxDraw = Math.max(...res.equityCurve.map((v,i)=> Math.max(...res.equityCurve.slice(0,i+1)) - v));
  document.getElementById('summaryContent').innerHTML = `Trades: <b>${n}</b> &nbsp; Net PnL: <b>${net.toFixed(2)} USD</b> &nbsp; Win rate: <b>${winRate}%</b> &nbsp; Ending equity: <b>${ending.toFixed(2)} USD</b> &nbsp; Max drawdown: <b>${maxDraw.toFixed(2)}</b>`;

  // populate trade table
  const tbody = document.querySelector('#tradeTable tbody'); tbody.innerHTML='';
  trades.forEach((t,i)=>{ const tr=document.createElement('tr'); tr.innerHTML = `<td class='p-2 border'>${i+1}</td><td class='p-2 border'>${t.type}</td><td class='p-2 border'>${t.entryTime||''}</td><td class='p-2 border'>${t.entryPrice?.toFixed(2)||''}</td><td class='p-2 border'>${t.exitPrice?.toFixed(2)||''}</td><td class='p-2 border'>${t.sl?.toFixed(2)||''}</td><td class='p-2 border'>${t.tp?.toFixed(2)||''}</td><td class='p-2 border'>${t.size?.toFixed(6)||''}</td><td class='p-2 border'>${(t.pnl||0).toFixed(2)}</td>`; tbody.appendChild(tr); });

  // charts
  const ctxE = document.getElementById('equityChart').getContext('2d'); if(window.eChart) window.eChart.destroy(); window.eChart = new Chart(ctxE, {type:'line', data:{labels: data1m.time, datasets:[{label:'Equity', data: res.equityCurve, fill:false, borderColor:'rgb(59,130,246)'}]}, options:{scales:{x:{display:false}}}});
  const ctxP = document.getElementById('priceChart').getContext('2d'); if(window.pChart) window.pChart.destroy(); window.pChart = new Chart(ctxP, {type:'line', data:{labels: data1m.time, datasets:[{label:'Close', data: data1m.close, fill:false, borderColor:'rgb(16,185,129)'}]}, options:{plugins:{legend:{display:false}}, elements:{point:{radius:0}}}});

  parsedResults = {trades: trades, equity: res.equityCurve};
}

document.getElementById('runBtn').addEventListener('click', buildAndRun);
function downloadCSV(){ if(!parsedResults) return alert('No results yet'); const rows = parsedResults.trades.map((t,i)=> ({idx:i+1, type:t.type, entryTime:t.entryTime, entryPrice:t.entryPrice, exitTime:t.exitTime, exitPrice:t.exitPrice, sl:t.sl, tp:t.tp, size:t.size, pnl:t.pnl })); const header = Object.keys(rows[0]||{}); const csv = [header.join(',')].concat(rows.map(r=> header.map(h=> r[h]!==undefined? r[h] : '').join(','))).join('
'); const blob = new Blob([csv], {type:'text/csv'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='backtest_trades.csv'; a.click(); URL.revokeObjectURL(url); }

document.getElementById('downloadBtn').addEventListener('click', downloadCSV);
</script>
</body>
</html>
