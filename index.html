<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BTCUSDT Scalping Backtester (Client-side)</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>html,body,#app{height:100%} .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace}</style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div id="app" class="p-6 max-w-6xl mx-auto">
    <h1 class="text-2xl font-semibold mb-4">BTCUSDT Scalping Backtester (client-side)</h1>

    <div class="bg-white shadow rounded p-4 mb-4">
      <label class="block font-medium mb-1">Upload CSV (5m OHLCV)</label>
      <input id="fileInput" type="file" accept=".csv" class="mb-3" />
      <div class="text-sm text-gray-600 mb-2">CSV should contain columns: <span class="mono">open_time,open,high,low,close,volume</span> (timestamps ISO or Binance ms). No data leaves your browser.</div>

      <div class="grid grid-cols-2 gap-4">
        <div>
          <label class="block">EMA short (5m)</label>
          <input id="emaShort" type="number" value="9" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">EMA long (5m)</label>
          <input id="emaLong" type="number" value="21" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">H1 EMA fast</label>
          <input id="h1_ema_fast" type="number" value="20" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">H1 EMA slow</label>
          <input id="h1_ema_slow" type="number" value="50" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">ATR period</label>
          <input id="atrPeriod" type="number" value="14" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">Risk per trade (%)</label>
          <input id="riskPct" type="number" value="1" step="0.1" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">TP (Ã—ATR)</label>
          <input id="tpMult" type="number" value="1.5" step="0.1" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block">Fee round-turn (%)</label>
          <input id="feePct" type="number" value="0.08" step="0.01" class="w-full p-2 border rounded" />
        </div>
      </div>

      <div class="mt-4 flex space-x-2">
        <button id="runBtn" class="px-4 py-2 bg-blue-600 text-white rounded shadow">Run Backtest</button>
        <button id="downloadBtn" class="px-4 py-2 bg-green-600 text-white rounded shadow">Download Trades CSV</button>
      </div>
    </div>

    <div id="summary" class="bg-white shadow rounded p-4 mb-4 hidden">
      <h2 class="font-semibold text-lg mb-2">Summary</h2>
      <div id="summaryContent" class="text-sm"></div>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
      <div class="bg-white shadow rounded p-4">
        <h3 class="font-medium mb-2">Equity Curve</h3>
        <canvas id="equityChart" height="200"></canvas>
      </div>

      <div class="bg-white shadow rounded p-4">
        <h3 class="font-medium mb-2">Price (close) + trade markers</h3>
        <canvas id="priceChart" height="200"></canvas>
      </div>
    </div>

    <div class="bg-white shadow rounded p-4 mt-4">
      <h3 class="font-medium mb-2">Trade Log</h3>
      <div class="overflow-auto max-h-64">
        <table id="tradeTable" class="w-full text-sm table-auto border-collapse">
          <thead><tr class="bg-gray-100"><th class="p-2 border">#</th><th class="p-2 border">Type</th><th class="p-2 border">Entry Time</th><th class="p-2 border">Entry</th><th class="p-2 border">Exit</th><th class="p-2 border">SL</th><th class="p-2 border">TP</th><th class="p-2 border">Size</th><th class="p-2 border">PnL (USD)</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="text-xs text-gray-600 mt-3">Made for local/backtest use. No data leaves your browser.</div>
  </div>

<script>
// ---- Utilities: CSV parse (simple) ----
function parseCSV(text){
  const lines = text.split(/\r?\n/).filter(r=>r.trim());
  const header = lines[0].split(/,|;|\t/).map(h=>h.trim());
  const rows = lines.slice(1).map(l=>{
    const parts = l.split(/,|;|\t/);
    const obj = {};
    header.forEach((h,i)=> obj[h]=parts[i]);
    return obj;
  });
  return {header, rows};
}

// ---- Indicator implementations ----
function ema(values, period){
  const k = 2/(period+1);
  const out = [];
  let prev = values.slice(0,period).reduce((a,b)=>a+b,0)/period;
  for(let i=0;i<values.length;i++){
    if(i<period-1){ out.push(null); continue; }
    if(i===period-1){ out.push(prev); continue; }
    prev = values[i]*k + prev*(1-k);
    out.push(prev);
  }
  return out;
}

function sma(values, period){
  const out=[]; let sum=0;
  for(let i=0;i<values.length;i++){
    sum += values[i];
    if(i>=period) sum -= values[i-period];
    out.push(i<period-1?null:sum/period);
  }
  return out;
}

function rsi(values, period){
  const out = [];
  let gains=0, losses=0;
  for(let i=1;i<values.length;i++){
    const change = values[i]-values[i-1];
    gains += Math.max(0,change);
    losses += Math.max(0,-change);
    if(i>=period){
      if(i>period){
        const prevChange = values[i-period+1]-values[i-period];
        gains = gains - Math.max(0, prevChange);
        losses = losses - Math.max(0, -prevChange);
      }
      const avgGain = gains/period; const avgLoss = losses/period;
      const rs = avgLoss===0?100:(avgGain/avgLoss);
      out[i]=100 - (100/(1+rs));
    } else out[i]=null;
  }
  out[0]=null; return out;
}

function macd(values, shortP=12,longP=26,signalP=9){
  const emaShort = ema(values, shortP);
  const emaLong = ema(values, longP);
  const macdLine = values.map((v,i)=> (emaShort[i]!=null && emaLong[i]!=null) ? emaShort[i]-emaLong[i] : null);
  const macdVals = macdLine.map(v=> v==null?0:v);
  const signal = ema(macdVals, signalP);
  const hist = macdLine.map((v,i)=> (v!=null && signal[i]!=null)? v - signal[i] : null);
  return {macdLine, signal, hist};
}

function atr(high, low, close, period){
  const tr=[]; for(let i=0;i<close.length;i++){
    if(i===0){ tr.push(high[i]-low[i]); continue; }
    tr.push(Math.max(high[i]-low[i], Math.abs(high[i]-close[i-1]), Math.abs(low[i]-close[i-1])));
  }
  return sma(tr, period);
}

// ---- Backtest engine ----
function runBacktest(data, params){
  const n = data.close.length;
  const emaS = ema(data.close, params.emaShort);
  const emaL = ema(data.close, params.emaLong);
  const h1_ema_fast = ema(data.h1_close, params.h1_ema_fast);
  const h1_ema_slow = ema(data.h1_close, params.h1_ema_slow);
  // map H1 values to 5m by nearest index (we will have h1 array aligned by timestamps in input)
  const rsiVals = rsi(data.close, params.rsiPeriod);
  const macdRes = macd(data.close, params.macdShort, params.macdLong, params.macdSignal);
  const atrVals = atr(data.high, data.low, data.close, params.atrPeriod);

  const trades = [];
  let equity = params.initialEquity;
  const equityCurve = [];
  let position = null;
  let entryIndex = null;
  let positionSize = 0;

  for(let i=0;i<n;i++){
    // skip until indicators ready
    if(emaS[i]==null || emaL[i]==null || rsiVals[i]==null || atrVals[i]==null) { equityCurve.push(equity); continue; }

    // H1 trend: find corresponding H1 index by timestamp mapping
    const h1Idx = data.h1_map[i];
    const trendUp = h1_ema_fast[h1Idx] != null && h1_ema_fast[h1Idx] > h1_ema_slow[h1Idx];
    const trendDown = h1_ema_fast[h1Idx] != null && h1_ema_fast[h1Idx] < h1_ema_slow[h1Idx];

    const price = data.close[i];
    const atrVal = atrVals[i];

    // entry
    if(!position){
      // long
      if(emaS[i] > emaL[i] && rsiVals[i] > 50 && macdRes.hist[i] > 0 && trendUp){
        const sl = price - atrVal;
        const tp = price + params.tpMult * atrVal;
        const riskAmount = equity * (params.riskPct/100);
        positionSize = riskAmount / (price - sl);
        position = {type:'long', entryPrice:price, sl, tp, size:positionSize, entryIndex:i};
        trades.push(Object.assign({entryTime:data.time[i]}, position));
      }
      // short
      else if(emaS[i] < emaL[i] && rsiVals[i] < 50 && macdRes.hist[i] < 0 && trendDown){
        const sl = price + atrVal;
        const tp = price - params.tpMult * atrVal;
        const riskAmount = equity * (params.riskPct/100);
        positionSize = riskAmount / (sl - price);
        position = {type:'short', entryPrice:price, sl, tp, size:positionSize, entryIndex:i};
        trades.push(Object.assign({entryTime:data.time[i]}, position));
      }
    } else {
      // manage
      if(position.type==='long'){
        if(price <= position.sl || price >= position.tp){
          const exitPrice = price;
          const gross = (exitPrice - position.entryPrice) * position.size;
          const fee = (position.entryPrice*position.size + exitPrice*position.size) * (params.feePct/100);
          const pnl = gross - fee;
          trades[trades.length-1].exitPrice = exitPrice; trades[trades.length-1].exitTime = data.time[i]; trades[trades.length-1].pnl = pnl;
          equity += pnl; position = null;
        }
      } else {
        if(price >= position.sl || price <= position.tp){
          const exitPrice = price;
          const gross = (position.entryPrice - exitPrice) * position.size;
          const fee = (position.entryPrice*position.size + exitPrice*position.size) * (params.feePct/100);
          const pnl = gross - fee;
          trades[trades.length-1].exitPrice = exitPrice; trades[trades.length-1].exitTime = data.time[i]; trades[trades.length-1].pnl = pnl;
          equity += pnl; position = null;
        }
      }
    }
    equityCurve.push(equity);
  }

  return {trades, equityCurve};
}

// ---- CSV -> data mapping & UI handlers ----
let rawRows = [];
let parsedData = null;

function tryParseTimestamp(v){
  if(!v) return null;
  // if looks like milliseconds integer
  if(/^[0-9]{12,}$/.test(v)) return new Date(Number(v));
  // try iso
  const d = new Date(v);
  if(!isNaN(d)) return d;
  // try replacing space with T
  const d2 = new Date(v.replace(' ', 'T'));
  if(!isNaN(d2)) return d2;
  return null;
}

function buildDataStructure(rows){
  // rows: array of objects from CSV parse
  const time = [], open=[], high=[], low=[], close=[], volume=[];
  for(const r of rows){
    const t = tryParseTimestamp(r.open_time || r.openTime || r[Object.keys(r)[0]]);
    if(!t) continue;
    time.push(t.toISOString());
    open.push(parseFloat(r.open));
    high.push(parseFloat(r.high));
    low.push(parseFloat(r.low));
    close.push(parseFloat(r.close));
    volume.push(parseFloat(r.volume || r.qty || 0));
  }
  return {time, open, high, low, close, volume};
}

function resampleToH1(data){
  // data aligned to 5m timestamps in ISO strings (assumed sorted ascending)
  const h1_time = []; const h1_close = [];
  const map = new Array(data.time.length).fill(0);
  let currentHour = null; let lastClose = null; let idx=0;
  for(let i=0;i<data.time.length;i++){
    const d = new Date(data.time[i]);
    const hourKey = d.getUTCFullYear()+'-'+d.getUTCMonth()+'-'+d.getUTCDate()+'-'+d.getUTCHours();
    if(currentHour===null) currentHour = hourKey;
    if(hourKey !== currentHour){
      // push previous hour close
      h1_time.push(prevTime);
      h1_close.push(lastClose);
      currentHour = hourKey;
      idx = h1_time.length-1;
    }
    // map this 5m index to latest h1 idx (we'll fill after loop)
    map[i] = h1_time.length; // placeholder
    lastClose = data.close[i];
    prevTime = data.time[i];
  }
  // push last
  if(lastClose!=null){ h1_time.push(prevTime); h1_close.push(lastClose); }
  // create mapping by reassigning nearest index: for each 5m find h1 index where its hour equals
  const realMap = [];
  for(let i=0;i<data.time.length;i++){
    const d = new Date(data.time[i]);
    const hh = d.getUTCHours(); const day = d.getUTCDate(); const month = d.getUTCMonth(); const year = d.getUTCFullYear();
    // find in h1_time with same year/month/day/hour
    let found = 0;
    for(let j=0;j<h1_time.length;j++){
      const dh = new Date(h1_time[j]);
      if(dh.getUTCHours()===hh && dh.getUTCDate()===day && dh.getUTCMonth()===month && dh.getUTCFullYear()===year){ found=j; break; }
    }
    realMap.push(found);
  }
  return {h1_time, h1_close, map:realMap};
}

// UI events
document.getElementById('fileInput').addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    const parsed = parseCSV(evt.target.result);
    rawRows = parsed.rows;
    alert('CSV loaded: '+rawRows.length+' rows');
  };
  reader.readAsText(f);
});

let equityChart=null, priceChart=null;

function clearCharts(){ if(equityChart) equityChart.destroy(); if(priceChart) priceChart.destroy(); }

async function onRun(){
  if(!rawRows.length){ alert('Please upload CSV first'); return; }
  const params = {
    emaShort: parseInt(document.getElementById('emaShort').value),
    emaLong: parseInt(document.getElementById('emaLong').value),
    h1_ema_fast: parseInt(document.getElementById('h1_ema_fast').value),
    h1_ema_slow: parseInt(document.getElementById('h1_ema_slow').value),
    atrPeriod: parseInt(document.getElementById('atrPeriod').value),
    tpMult: parseFloat(document.getElementById('tpMult').value),
    riskPct: parseFloat(document.getElementById('riskPct').value),
    feePct: parseFloat(document.getElementById('feePct').value),
    initialEquity: 1000,
    rsiPeriod: 14,
    macdShort:12, macdLong:26, macdSignal:9
  };

  const data = buildDataStructure(rawRows);
  const h1 = resampleToH1(data);
  const dataObj = Object.assign({}, data, {h1_close: h1.h1_close, h1_map: h1.map});

  const result = runBacktest(dataObj, params);

  // show summary
  document.getElementById('summary').classList.remove('hidden');
  const trades = result.trades;
  const n = trades.length;
  const net = trades.reduce((s,t)=> s + (t.pnl||0), 0);
  const wins = trades.filter(t=> (t.pnl||0) > 0).length;
  const winRate = n? (wins/n*100).toFixed(2):0;
  const ending = result.equityCurve[result.equityCurve.length-1] || params.initialEquity;
  const maxDraw = Math.max(...result.equityCurve.map((v,i)=> Math.max(...result.equityCurve.slice(0,i+1)) - v));

  document.getElementById('summaryContent').innerHTML = `Trades: <b>${n}</b> &nbsp; Net PnL: <b>${net.toFixed(2)} USD</b> &nbsp; Win rate: <b>${winRate}%</b> &nbsp; Ending equity: <b>${ending.toFixed(2)} USD</b> &nbsp; Max drawdown: <b>${maxDraw.toFixed(2)}</b>`;

  // populate trade table
  const tbody = document.querySelector('#tradeTable tbody'); tbody.innerHTML='';
  trades.forEach((t,i)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td class='p-2 border'>${i+1}</td><td class='p-2 border'>${t.type}</td><td class='p-2 border'>${t.entryTime||''}</td><td class='p-2 border'>${t.entryPrice?.toFixed(2)||''}</td><td class='p-2 border'>${t.exitPrice?.toFixed(2)||''}</td><td class='p-2 border'>${t.sl?.toFixed(2)||''}</td><td class='p-2 border'>${t.tp?.toFixed(2)||''}</td><td class='p-2 border'>${t.size?.toFixed(6)||''}</td><td class='p-2 border'>${(t.pnl||0).toFixed(2)}</td>`;
    tbody.appendChild(tr);
  });

  // charts
  clearCharts();
  const ctxE = document.getElementById('equityChart').getContext('2d');
  equityChart = new Chart(ctxE, {type:'line', data:{labels: data.time, datasets:[{label:'Equity', data: result.equityCurve, fill:false, borderColor:'rgb(59,130,246)'}]}, options:{scales:{x:{display:false}}}});

  const ctxP = document.getElementById('priceChart').getContext('2d');
  const priceDataset = {label:'Close', data: data.close, fill:false, borderColor:'rgb(16,185,129)'};
  const markers = trades.map(t=>{ return {x: t.entryTime, y: t.entryPrice, type:t.type}; });
  priceChart = new Chart(ctxP, {type:'line', data:{labels: data.time, datasets:[priceDataset]}, options:{plugins:{legend:{display:false}}, elements:{point:{radius:0}}}});

  // store parsedData for download
  parsedData = {params, dataObj, trades, equityCurve: result.equityCurve};
}

function downloadCSV(){
  if(!parsedData) return alert('No results yet');
  const rows = parsedData.trades.map((t,i)=> ({
    idx:i+1, type:t.type, entryTime:t.entryTime, entryPrice:t.entryPrice, exitTime:t.exitTime, exitPrice:t.exitPrice, sl:t.sl, tp:t.tp, size:t.size, pnl:t.pnl
  }));
  const header = Object.keys(rows[0]||{});
  const csv = [header.join(',')].concat(rows.map(r=> header.map(h=> r[h]!==undefined? r[h] : '').join(','))).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download = 'backtest_trades.csv'; a.click(); URL.revokeObjectURL(url);
}

document.getElementById('runBtn').addEventListener('click', onRun);
document.getElementById('downloadBtn').addEventListener('click', downloadCSV);
</script>
</body>
</html>
